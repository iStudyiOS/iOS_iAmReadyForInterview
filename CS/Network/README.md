# Network

<details>
<summary> HTTPS이 보안이 뛰어난 이유 </summary>
<div markdown="1">
<br>
  
- ‘HTTP vs HTTPS 차이’는 바로 **SSL 인증서**
- SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화하는데, 쉽게 말해서 **데이터를 암호로** 바꾼다고 생각하면 쉽다.
- 따라서 중간에 누가 훔쳐봐도 기본적인 보안 대응이 가능함.
- 이렇게 전송된 데이터는 중간에서 누군가 훔쳐 낸다고 하더라도 **데이터가 암호화되어있기 때문에 해독할 수 없다.**

- 그 외에도 HTTPS는 **TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지**한다.
- TLS은 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 수정되거나 손상되는 것을 방지
- 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능도 제공
    - 부연설명: TLS때문에 나쁜사용자가 라우터에서 IP주소를 조작하더라도 HTTPS를 쓰면 무결성 때문에 올바른 서버주소와 통신을 할 수 있게 해준다!!
- 즉, 내가 원하는 서버IP 주소와 통신할 수 있는 것은 TLS때문이고, 데이터를 훔쳐봐도 해독할 수 없게 해주는것은 SSL때문이다.

<br>
</div>
</details>

<details>
<summary> HTTP Connections에서 Non-Persistent 와 Persistent </summary>
<div markdown="1">
<br>
  
- `Non-Persistent`
    - TCP 연결 한번에 **최대 하나의 객체**를 전송할 수 있다.
    - 필요할 때에 TCP연결을 한다.
    - 오브젝트마다 2번의 RTT+전송타임이 걸린다고 볼 수 있음.

- `Persistent`
    - TCP 연결 한번에 **여러개의 객체**를 전송할 수 있다.
    - 한번 TCP연결을 하고 종료 될때까지 재사용 한다.
    - 여러번의 오브젝트를 보낼 수 있다.
    - 평균적으로는 1번의 RTT+전송타임이 걸린다고 볼 수 있음.
  
<br>
</div>
</details>

<details>
<summary> TCP/UDP 차이 </summary>
<div markdown="1">
<br>

- TCP는 UDP에 비해 하는일이 많아서 헤더가 기본적으로 UDP보다 복잡하고 크다.
- TCP는 Connection Oriented 기반이라 handshaking과정이 있고, UDP는 연결과정은 없음.
- TCP는 신뢰가 보장된 프로토콜이고, UDP도 헤더에 체크썸이 있어 기본적인 비트에러감지정돈 해준다.
- 그외에도 TCP는 congestion control, flow control, 3 duplicate ack, 등등 한다고 햇음

<br>

  ![스크린샷 2022-03-28 오후 10 15 02](https://user-images.githubusercontent.com/74236080/161303983-0919112a-5839-4f42-88d0-d517d9345393.png)

<br>
</div>
</details>


<details> 
  <summary> 캡슐화 & 역캡슐화 란? </summary>
  
  <br>
  
  > : Encapsulation & Decapsulation

네트워크를 통해 데이터를 보낼 때 `캡슐화`와 `역캡슐화` 과정이 이루어진다.

### 캡슐화/역캡슐화를 하는 이유?
- 데이터를 보내기 위해서는 데이터의 헤더에 필요한 정보를 붙여서 다음 계층으로 보내야 하기 때문이다.

### 간략 정의
- 캡슐화
    - 위의 이유로 헤더를 덧붙여 나가는 것을 `캡슐화` 라고 한다.
    - 송신하는 측에서 캡슐화를 통해 데이터를 전송한다.
- 역캡슐화
    - 수신하는 측에서 역캡슐화를 통해 헤더를 벗겨내 최초로 보낸 데이터 형태를 구하는 과정을 `역캡슐화` 라고 한다.
  
 </details>



<details> 
  <summary> TCP / UDP 사용 예시 및 비교 </summary>
  
- TCP
    - 순서를 보장하고 신뢰도가 높다는 점에서 HTTP 통신, 이메일, 파일전송 등 순서대로 도착해야 하는 상황에 사용된다.

- UDP
    - 순서는 보장해주지 못하지만 실시간으로 반응해야하는 실시간 방송이나 게임 등에서 사용된다.

> Q. 채팅 구현 시 TCP를 사용하는 이유는??
- 연결된 상태에서 순서대로 송신자와 숫니자가 보낸 메세지를 그대로 전송할 수 있기 때문이다. 
-> 따라서 양방향 통신에 유리하다.
(UDP는 그 순서를 보장해주지 못하기 때문.)
  
  ## 비교
|비교|TCP|UDP|
|---|:---:|:---:|
|신뢰성|O|X|
|연결성|X|O|
|송수신자 간의 연결 여부|연결되어야 통신 가능|연결 없이도 통신 가능|
```
- TCP는 신뢰성이 있고 연결지향적이지만, UDP는 신뢰성이 없고 비연결적이다.
- TCP는 송신-수신자 연결이 되어있어야 통신이 가능하지만, UDP는 연결되어있지 않아도 가능하다.
```
  
 </details>


<details> 
  <summary>  OSI 7계층 </summary>
  
  - Layer 1: 물리계층
  - Layer 2: 데이터 링크 계층
  - Layer 3: 네트워크 계층
  - Layer 4: 전송 계층
  - Layer 5: 세션 계층
  - Layer 6: 표현 계층
  - Layer 7: 응용 계층
  
 </details>

<details> 
  <summary>  Socket 통신 </summary>
  
  - 서버와 클라이언트 양방향 연결이 이루어지는 통신으로, 클라이언트와 서버 서로간에 요청과 응답을 받을 수 있는 통신.
  - 실시간으로 이루어져야하는 네트워크 연결에 적합하다.(스트리밍, 채팅 등등...)
  
 </details>


<details> 
  <summary>  3-Way-Handshakes </summary>
  
  - 간략하게 설명하자면, 3-Way-Handshake 는 3번의 패킷 전송 과정을 의미합니다.
    
    3번의 패킷 전송 과정은 다음과 같습니다.
    
    1. 요청자가 수신자에게 SYN 패킷을 전송
    
    2. 수신자가 요청자에게 SYN+ACK 패킷을 전송
    
    3. 요청자가 수신자에게 ACK 패킷을 전송 
    
    위의 '3'번의 패킷 전송으로 '3'-Way-Handshakes 라고 불려집니다.
    밑에서 후술할 '4'-Way-Handshakes는 '4'번의 패킷 전송 과정을 거치게됩니다.
  
  - 3-Way-Handshakes 에서의 송신자와 수신자간의 연결 요청부터 연결 확립(Established) 되기 까지의 과정을 설명하겠습니다.
    1. **CLOSED**
    수신자, 요청자간의 연결요청이 없는 상태입니다.
    
    2. **LISTEN**
    수신자가 요청자로 부터의 연결을 받아들일 준비가 되었고, 대기상태에 들어간 상태를 의미합니다. 
    
    3. **SYN_SENT**
    요청자가 수신자에게 연결요청을 합니다. SYN패킷에 무작위로 생성된 시퀀스 번호를 담아 전송합니다. 
    
    4. **SYN_RECV**
    수신자가 요청자로부터 전송받은 SYN패킷을 정상적으로 수신된 상태입니다. 이때, 요청자로부터 받은 시퀀스번호를 정상적으로 받았다는 의미로 ACK 값을 전송받은 시퀀스번호의 1 만큼 더한 값으로 지정하고, 마찬가지로 무작위 번호를 SYN 패킷에 담아 SYN패킷과 ACK신호를 요청자에게 전송합니다.
    
    5. **ESTABLISHED**
    요청자는 전송받은 ACK 신호를 처음에 전송한 무작위 시퀀스번호와 대조하여 1 만큼의 차이가 나는지 확인하고 만약 정상적으로 연결이 성립이 되었는지(정상적으로 송,수신이 되었는지) 확인이되면 수신자로부터 전송받은 무작위 시퀀스번호에 마찬가지로 1 만큼 더한값을 ACK 값으로 설정하고 다시 서버에게 전송한뒤, 요청자는 ESTABLISHED 상태로 들어가게된다. 이후 서버에서 다시 요청자에게 전송받은 ACK신호의 값을 비교하고 정상적으로 연결이 성립되었다고 확인되면 수신자또한 ESTABLISHED 상태로 들어가게되며, 이후 데이터 통신이 이루어지게된다.
  
  - 4-Way-Handshake 에서의 연결 종료요청부터 연결 종료까지의 과정을 설명하겠습니다.
  
        1. **FIN_WAIT_1**
        요청자가 수신자에게 FIN 패킷을 전송하여 연결 종료를 요청합니다. 포함되어 있는 시퀀스 번호는 올바른 시퀀스에 맞는 번호를 사용합니다.
        2. **CLOSE_WAIT**
        요청자에게 FIN 패킷을 받은 수신자는 요청자가 보낸 시퀀스 번호에 1 만큼 더한 숫자를 요청자에게 다시 보내 정상적으로 FIN 패킷을 수신했다고 알려줍니다. 
        3. **FIN_WAIT_2**
        요청자는 수신자에서 받은 시퀀스 번호를 1 만큼 차이가 나는지 확인 합니다. 이후 데이터 전송이 끝나기 전까지 FIN_WIAT2 상태로 들어가 수신자가 FIN 패킷을 보낼때까지 대기합니다.
        4. **LAST_ACK**
        수신자가 더 이상 전송할 데이터가 없으면 요청자에게 FIN패킷을 전송합니다. 같이 전송되는 시퀀스 번호는 전송해야하는 데이터의 시퀀스 번호를 사용하며, 승인번호는 마지막으로 응답한 승인번호를 그대로 사용합니다. 이후 요청자가 다시 승인 번호를 보내줄때까지 LAST_ACK 상태로 들어가 대기합니다.
        5. **TIME_WAIT**
        요청자는 수신자가 보낸 수신자가 보낸 시퀀스 번호에 1을 더한 값을 승인번호로 생성하여 수신자에게 ACK 패킷을 전송하여 응답합니다. 이후, 요청자는 TIME_WAIT 상태로 대기하며 데드락에 빠지지 않게 방지합니다. 이때 대기하는 시간은 2 MSL(Maximum Segment Lifetime)입니다. 
        6. **CLOSED**
        수신자는 요청자가 보낸 ACK 패킷을 확인하면 CLOSED 상태로 들어가며 연결을 종료합니다. 요청자에서도 2 MSL 만큼의 시간이 지나면 CLOSED 상태로 들어가며 연결을 종료하게 됩니다.

 </details>
